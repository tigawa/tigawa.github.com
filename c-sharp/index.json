[{"ref":"https://tigawa.github.io/c-sharp/%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89/","title":"演算子のオーバーロード","section":"c-sharp","date":"2019.09.28","body":"operator キーワードを使うと演算子をオーバーロードして自分で定義することができます。\nさきにオーバーロードできない演算子を示します。\n\u0026amp;\u0026amp; () . ? ?? [] || = =\u0026gt; -\u0026gt; as checked default is new sizeof typeof unchecked\nサンプル 基本的ルールとしてインスタンスは生成して返すべきです。でないと引数でもらったオブジェクトの中を更新してしまい次の関係になりません。\nvar c = a + b \n// 二項演算子「＋」オーバーロード public static ThreeD operator +(ThreeD op1, ThreeD op2) { ThreeD result = new ThreeD(); result.x = op1.x + op2.x; result.y = op1.y + op2.y; result.z = op1.z + op2.z; return result; } var a = new ThreeD(1, 2, 3); var b = new ThreeD(10, 10, 10); var c = a + b; 単行演算子においても同じです。\na++ のような使い方する場合、オブジェクトを新規に作って大丈夫？と思いますよね？ これはこれで正しく加算されました。たぶん新規に生成したインスタンスに置き換わっているのでしょう。\n// 単項演算子「＋+」オーバーロード public static ThreeD operator ++(ThreeD op) { var result = new ThreeD(); result.x = op.x + 1; result.y = op.y + 1; result.z = op.z + 1; return result; } var a = new ThreeD(1, 2, 3); a++; 注意事項 public static 戻り型 oparator 演算子(仮引数 オペランド){ }  オペランドの方は、その演算子をオーバロードしているクラスと同じでなければなりません。 条件演算子をオーバロードすることはできません。また演算子の優先順位をかえることはできません。 "},{"ref":"https://tigawa.github.io/c-sharp/%E5%8F%AF%E5%A4%89%E9%95%B7%E5%BC%95%E6%95%B0/","title":"可変長引数","section":"c-sharp","date":"2019.09.28","body":"C#の可変長引数は、params 修飾子をつけます。\nあーたしかに変数名をparamsにするとコンパイルエラーになってたなー\n//定義例 public static int MinVal(params int[] nums)　{...} //呼び出し例 MainVal(3,5,4,8); MainVal(4,8); MainVal(); paramsは引数が0でもエラーにはならないです。\n比較    C# Java     MinVal(params int[] nums) MinVal(int... nums)    以上\n"},{"ref":"https://tigawa.github.io/c-sharp/main_method/","title":"mainメソッド","section":"c-sharp","date":"2019.09.07","body":"mainメソッドの4つのオーバロード\nstatic void Main() static void Main(string[] args) static int Main() static int Main(string[] args) "},{"ref":"https://tigawa.github.io/c-sharp/static_class/","title":"静的クラスと静的コンストラクタ","section":"c-sharp","date":"2019.09.07","body":"静的クラスと静的コンストラクタについてまとめます。\n静的クラス class に staticをつけると静的クラスになります。\nstatic class Test { //- 特徴  オブジェクトインスタンスを生成できない。 クラス内に静的メンバしか定義できない。  Utilsクラスを宣言するとき、staticを宣言してもいいかもしれません。\n静的コンストラクタ Class Sample { static Sample() { //静的コンストラクタ } 特徴  クラスがロードされるタイミングで１度実行されるようになる Javaでいうstaticブロック(イニシャライザ)にあたる  本当に１回だけ実行したいかつ、コンストラクタの前に実行したい場合に利用できそうです。\n以上\n"},{"ref":"https://tigawa.github.io/c-sharp/tec1/","title":"Dictionaryを継承してgetしたときに該当データがない場合は、TValueで指定されたクラスをnewして返す方法","section":"c-sharp","date":"2019.08.31","body":"Dictionaryを継承してgetしたときに該当データがない場合は、TValueで指定されたクラスをnewして返す方法を紹介します。\nポイント  アクセサをオーバライドする。 TValueをwhereで限定することで、メソッド内で new TValue()を可能にできる。 (これはJavaではできない。いいところ！)  サンプルコード public class SDic\u0026lt;TKey, TValue\u0026gt; : Dictionary\u0026lt;TKey, TValue\u0026gt; where TValue : new() { public new TValue this[TKey key] { get { TValue value; return TryGetValue(key, out value) ? value : new TValue(); } set { base[key] = value; } } } インデクサーのべからず集  参照パラメータや出力パラメータとしてメソッドにわたすことはできません。 インデクサーはstatic修飾子をつけて宣言できません。  以上です。\n"},{"ref":"https://tigawa.github.io/c-sharp/ref_out/","title":"参照パラメータと出力パラメータ","section":"c-sharp","date":"2019.08.15","body":"参照パラメータ ref をつけると結果を呼び出し側に返すことができる。\n使い方 int a = 0; Console.WriteLine(a); obj.Sqr(ref a); Console.WriteLine(a); public void Sqr(ref int i) { i = i * i; } 制限事項 ref を宣言するとnullを設定することはできない\n出力パラーメタ out をつけると結果を呼び出し側に返すことができる。\n使い方 bool isSquare; int a = RectInfo(30, 30, out isSquare); public int RectInfo(int side1, int side2, out bool isSquare) { if(side1==side2) isSquare = true; else isSquare = false; return side1 * side2; } 制限事項 out を指定した引数には必ず値を設定しないと行けない。 設定しないとコンパイルエラーになる。\n"},{"ref":"https://tigawa.github.io/c-sharp/string/","title":"文字列","section":"c-sharp","date":"2019.08.15","body":"よくつかう文字列に関する部品をJavaとC#で対比してまとめます。\nnull 空白文字列のチェック    Java [Apache] C# [標準] 用途     StringUtils.isEmpty() String.IsNullOrEmpty() nullか空文字の場合にtrueを返す。   StringUtils.isBlank() String.IsNullOrWhiteSpace() nullか空文字か空白文字列(全角空白も含む)の場合にtrueを返す。    実行例 Assert.AreEqual(true, String.IsNullOrEmpty(null)); Assert.AreEqual(true, String.IsNullOrEmpty(\u0026quot;\u0026quot;)); Assert.AreEqual(false, String.IsNullOrEmpty(\u0026quot; \u0026quot;));//半角空白 Assert.AreEqual(false, String.IsNullOrEmpty(\u0026quot;　\u0026quot;));//全角空白 Assert.AreEqual(false, String.IsNullOrWhiteSpace(\u0026quot;a　\u0026quot;)); Assert.AreEqual(true, String.IsNullOrWhiteSpace(null)); Assert.AreEqual(true, String.IsNullOrWhiteSpace(\u0026quot;\u0026quot;)); Assert.AreEqual(true, String.IsNullOrWhiteSpace(\u0026quot; \u0026quot;));//半角空白 Assert.AreEqual(true, String.IsNullOrWhiteSpace(\u0026quot;　\u0026quot;));//全角空白 Assert.AreEqual(false, String.IsNullOrWhiteSpace(\u0026quot;a　\u0026quot;)); "},{"ref":"https://tigawa.github.io/c-sharp/archives/","title":"C#","section":"c-sharp","date":"2019.08.15","body":"過去の記事を全てみる\nざっとC#の歴史\n   基本1 基本2 応用     文字列 mainメソッド インデクサー   ref out 可変長引数    静的コンストラクタ 演算子のオーバーロード     命名規約    種類 Java C#(.NET)     クラス Pascal Pascal   インタフェース Pascal \u0026ldquo;I\u0026rdquo; + Pascal   パッケージ / ネームスペース Camel Pascal   メソッド Camel Pascal   ローカル変数 Camel Camel   メンバ変数 Came Pascal   定数 Snake Pascal   列挙定数 Snake Snake    "},{"ref":"https://tigawa.github.io/c-sharp/first/","title":"ざっとC#の歴史","section":"c-sharp","date":"2019.01.30","body":"C#について、勉強したことを自分のために少しづつまとめていきます。\nざっとC#の歴史  C言語が1970年〜1980年の構造化プログラミングの中から生まれた。 C言語にオブジェクト指向を取り入れた。C++が生まれた。  そのため当初は、\u0026ldquo;C with Classes\u0026quot;と呼ばれていたらしい。   JavaはC++に影響を受けて、1991年にSun Microsystemsが開発。 ただし、JavaからはWindows固有の機能が使えなかった。 そこで、windows固有機能も使用したいというニーズとともに、1980年代の後半にC#が誕生した。  バージョンアップの歴史  2.0 ジェネリックの部分型、匿名メソッド 3.0 LINQ, ラムダ式 4.0 動的言語ランタイムに関する新機能 ~ 途中 ~  実行環境  C#の実行には、.NET Frameworkを必要とする。  .NET Frameworkとは  高度に分散されたコンポーネントベースのアプリケーション開発と実行をサポートする環境のこと  .NET Framework = ランタイム(CLR)　+ ライブラリ  ソースコード -\u0026gt; 中間言語 MSIL -\u0026gt; JIT(Just in time)コンパイラに実行可能なコードに変換して実行する。  "}]